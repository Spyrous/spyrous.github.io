<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Wrapping an IP with an AXI interface in Vivado | Spyrous Blog</title>
<meta name=keywords content="AXI,Xilinx,Vivado,Vitis,FPGA"><meta name=description content="Introduction In this tutorial we will design a simple adder IP and use Xilinx Vivado AXI wrapper generator to allow our ARM cores to read/write to our IP through the AXI interface.
The high-level design will be the one in the image below. We will have 2 IPs. One is our custom made IP wrapped with AXI interface and an AXI BRAM controller just for demonstration purposes.
Tools Used The following tools where used to create this tutorial:"><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://www.spyroschiotakis.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://www.spyroschiotakis.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://www.spyroschiotakis.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://www.spyroschiotakis.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://www.spyroschiotakis.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Wrapping an IP with an AXI interface in Vivado"><meta property="og:description" content="Introduction In this tutorial we will design a simple adder IP and use Xilinx Vivado AXI wrapper generator to allow our ARM cores to read/write to our IP through the AXI interface.
The high-level design will be the one in the image below. We will have 2 IPs. One is our custom made IP wrapped with AXI interface and an AXI BRAM controller just for demonstration purposes.
Tools Used The following tools where used to create this tutorial:"><meta property="og:type" content="article"><meta property="og:url" content="https://www.spyroschiotakis.com/posts/wrapping_ip_with_axi/"><meta property="og:image" content="https://www.spyroschiotakis.com/%3Cimage%20path/url%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-15T11:30:03+00:00"><meta property="article:modified_time" content="2021-11-15T11:30:03+00:00"><meta property="og:site_name" content="spyroschiotakis"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.spyroschiotakis.com/%3Cimage%20path/url%3E"><meta name=twitter:title content="Wrapping an IP with an AXI interface in Vivado"><meta name=twitter:description content="Introduction In this tutorial we will design a simple adder IP and use Xilinx Vivado AXI wrapper generator to allow our ARM cores to read/write to our IP through the AXI interface.
The high-level design will be the one in the image below. We will have 2 IPs. One is our custom made IP wrapped with AXI interface and an AXI BRAM controller just for demonstration purposes.
Tools Used The following tools where used to create this tutorial:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.spyroschiotakis.com/posts/"},{"@type":"ListItem","position":2,"name":"Wrapping an IP with an AXI interface in Vivado","item":"https://www.spyroschiotakis.com/posts/wrapping_ip_with_axi/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Wrapping an IP with an AXI interface in Vivado","name":"Wrapping an IP with an AXI interface in Vivado","description":"Introduction In this tutorial we will design a simple adder IP and use Xilinx Vivado AXI wrapper generator to allow our ARM cores to read/write to our IP through the AXI interface.\nThe high-level design will be the one in the image below. We will have 2 IPs. One is our custom made IP wrapped with AXI interface and an AXI BRAM controller just for demonstration purposes.\nTools Used The following tools where used to create this tutorial:","keywords":["AXI","Xilinx","Vivado","Vitis","FPGA"],"articleBody":"Introduction In this tutorial we will design a simple adder IP and use Xilinx Vivado AXI wrapper generator to allow our ARM cores to read/write to our IP through the AXI interface.\nThe high-level design will be the one in the image below. We will have 2 IPs. One is our custom made IP wrapped with AXI interface and an AXI BRAM controller just for demonstration purposes.\nTools Used The following tools where used to create this tutorial:\nZyBo FPGA Vivado 2021.1 Ubuntu 20.04 LTS Hardware Part To begin start Xilinx Vivado and create a new design.\nTools --\u003e Create and Package New IP ...\nThen click Next \u003e\nOn the next screen select Create a new AXI4 peripheral and then click Next \u003e\nName your IP as you want. Me I named it axi_adder. Then click Next \u003e\nOn the tab with the interface of the AXI leave everything as is and just click Next \u003e\nAfter in the final tab select Edit IP and click Finish.\nThis will open your AXI wrapper IP in a new Vivado window. Inside this AXI wrapper we need to add our own IP. To add an IP click on the ‘+’ symbol.\nThen click Create File. In the window that pops up put us File Type SystemVerilog, File Name adder and File Location anywhere you want preferably in the same folder as the IP. Click OK and then Finish.\nA new window will popup called Define Module to help you create the header of your IP. You can ignore it since you will copy paste the code below. Click OK to generate the file.\nIn your hierarchy now you should have the adder file.\nIn the adder.sv file copy and paste the following code:\nmodule adder( input logic [31:0] num1, input logic [31:0] num2, output logic [31:0] sum ); assign sum = num1 + num2; endmodule Now we need to connect the 2 inputs to the 2 out of the 4 registers provided from the AXI slave interface and the output to one of the 2 remaining. To do this open the AXI slave file axi_adder_v1_0_S00_AXI.v and change the following parts:\nBetween lines 103 and 110 replace the ‘reg’ of slv_reg2 with ‘wire’ as it will be our output register.\n//---------------------------------------------- //-- Signals for user logic register space example //------------------------------------------------ //-- Number of Slave Registers 4 reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg0; reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg1; wire [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg2; // Turned to wire for the adder output reg [C_S_AXI_DATA_WIDTH-1:0]\tslv_reg3; From the process that writes to all slv_reg registers (lines 219-269) remove the slv_reg2 as it will be written from our IP.\nalways @( posedge S_AXI_ACLK ) begin if ( S_AXI_ARESETN == 1'b0 ) begin slv_reg0 \u003c= 0; slv_reg1 \u003c= 0; //\tslv_reg2 \u003c= 0; slv_reg3 \u003c= 0; end else begin if (slv_reg_wren) begin case ( axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] ) 2'h0: for ( byte_index = 0; byte_index \u003c= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 0 slv_reg0[(byte_index*8) +: 8] \u003c= S_AXI_WDATA[(byte_index*8) +: 8]; end 2'h1: for ( byte_index = 0; byte_index \u003c= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 1 slv_reg1[(byte_index*8) +: 8] \u003c= S_AXI_WDATA[(byte_index*8) +: 8]; end 2'h2: for ( byte_index = 0; byte_index \u003c= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 2 //\tslv_reg2[(byte_index*8) +: 8] \u003c= S_AXI_WDATA[(byte_index*8) +: 8]; end 2'h3: for ( byte_index = 0; byte_index \u003c= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 3 slv_reg3[(byte_index*8) +: 8] \u003c= S_AXI_WDATA[(byte_index*8) +: 8]; end default : begin slv_reg0 \u003c= slv_reg0; slv_reg1 \u003c= slv_reg1; //\tslv_reg2 \u003c= slv_reg2; slv_reg3 \u003c= slv_reg3; end endcase end end end And just before the endmodule keyword there are 2 comments saying ‘Add user logic here’. Between those comments add the following code:\n// Add user logic here adder adder_i ( .num1 (slv_reg0), .num2 (slv_reg1), .sum (slv_reg2) ); // User logic ends This will connect our IP’s 2 inputs to 2 of the slv_reg that we can read/write from the CPU and connect the output to slv_reg2 which we will be able to read-only.\nWARNING: It is adviced to try a synthesis run before closing the IP to make sure there was no mistake during the code editing part.\nAfter that after merging the changes and you are asked if you want to close the project click OK.\nBack on our design now that we created our IP we need to add it on our design. Just open the block design by clicking Open Block Design on the left and right click in the schematic and click Add IP... and search for axi_adder and add it in the design. Then on top you will again get the do automatic connection suggestion from Vivado. Click on it and let Vivado create a connection to our axi_adder automatically from the interconnect.\nIn the end your schematic diagram should look like the one on the image below:\nThen you need to create an HDL wrapper and generate the bitstream.\nAfter this is done export the hardware with the bitstream.\nOn the first window click Next \u003e and then on the next window from the options check the Include bitstream and then click Next \u003e. On the next window make sure you remember the path where you save the .xsa file as we will source it in the Vitis tool to create our software.\nThen open the Vitis toolchain by clicking from the top tabs Tools --\u003e Launch Vitis IDE and then click Launch on the next popup window to start the software part of the design.\nSoftware Part After Vitis SDK loads we start by creating a new application.\nOn the first popup welcome window click Next \u003e and then on the second window choose to create a new platform with the XSA file created from Vivado.\nThen on the next window called Application Project Details give a name to your project for example axi_adder_test and leave the remaining choices as they are. Next window called Domain click Next \u003e and on the final window called Templates choose Hello World and then click Finish.\nWe create this application to initiate our CPU cores to a working state and allow us to access the FPGA by lowering the level shifters.\nTo test our IP through software I put 2 ways. The first one which I consider the easiest is with XSCT. The second one is writing a C application and watching through a UART terminal the output.\nTesting the hardware with XSCT Now we need to first build the project and then run it. To build right-click the C application and run Build Project and wait for some seconds for it to build.\nAfter the application has been build connect to your FPGA board and power it on.\nRun the application on the FPGA. This will program the FPGA and run the hello world test on it.\nNow we should be able to use the XSCT console to access the FPGA part through the ARM cores. To do this you can run the commands below on the XSCT console.\nHere I use the first 2 registers of the design as input numbers and the third one as output of the sum of the addition. The addresses used were given from Vivado. You can find them in the address editor in Vivado tool in your schematic viewer.\nTesting the hardware with a C application We can also do it using a C program and a UART terminal to read the results. For a UART terminal in this example I used Putty and I opened it using sudo putty.\nTo find which port to listen to for UART data I did a dmesg on my terminal and when I powered-on my FPGA I saw which ttyUSB port it used.\nFor the UART baud rate (or the field Speed in Putty) you can look inside the comments in the helloworld.c file. It is 115200.\nNow copy this C code and replace the int main() program inside the helloworld.c file.\n#include #include \"platform.h\" #include \"xil_printf.h\" int main() { init_platform(); uint32_t *axi_adder_ptr = (uint32_t *) 0x43C00000; *axi_adder_ptr = 0x11223344; *(axi_adder_ptr + 1) = 0x11223344; print(\"Hello World\\n\\r\"); printf(\"The axi adder result is 0x%x\", *(axi_adder_ptr + 2)); cleanup_platform(); return 0; } Build the project and run again with your Putty session open and watch the output of the print.\nConclusion This concludes the tutorial of designing your hardware IP wrapping it with AXI interface in Vivado and testing its functionality through the Vitis SDK and Zynq cores.\n","wordCount":"1478","inLanguage":"en","image":"https://www.spyroschiotakis.com/%3Cimage%20path/url%3E","datePublished":"2021-11-15T11:30:03Z","dateModified":"2021-11-15T11:30:03Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.spyroschiotakis.com/posts/wrapping_ip_with_axi/"},"publisher":{"@type":"Organization","name":"Spyrous Blog","logo":{"@type":"ImageObject","url":"https://www.spyroschiotakis.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.spyroschiotakis.com/ accesskey=h title="Spyrous Blog (Alt + H)">Spyrous Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.spyroschiotakis.com/posts/ title=posts><span>posts</span></a></li><li><a href=https://www.spyroschiotakis.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://www.spyroschiotakis.com/about_me title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.spyroschiotakis.com/>Home</a>&nbsp;»&nbsp;<a href=https://www.spyroschiotakis.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Wrapping an IP with an AXI interface in Vivado</h1><div class=post-meta><span title='2021-11-15 11:30:03 +0000 +0000'>15 November 2021</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#tools-used aria-label="Tools Used">Tools Used</a></li><li><a href=#hardware-part aria-label="Hardware Part">Hardware Part</a></li><li><a href=#software-part aria-label="Software Part">Software Part</a><ul><li><a href=#testing-the-hardware-with-xsct aria-label="Testing the hardware with XSCT">Testing the hardware with XSCT</a></li><li><a href=#testing-the-hardware-with-a-c-application aria-label="Testing the hardware with a C application">Testing the hardware with a C application</a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>In this tutorial we will design a simple adder IP and use Xilinx Vivado AXI wrapper generator to allow our ARM cores to read/write to our IP through the AXI interface.</p><p>The high-level design will be the one in the image below. We will have 2 IPs. One is our custom made IP wrapped with AXI interface and an AXI BRAM controller just for demonstration purposes.</p><h2 id=tools-used>Tools Used<a hidden class=anchor aria-hidden=true href=#tools-used>#</a></h2><p>The following tools where used to create this tutorial:</p><ul><li>ZyBo FPGA</li><li>Vivado 2021.1</li><li>Ubuntu 20.04 LTS</li></ul><p><img loading=lazy src=/first_post/axi_custom.png#center alt="Final design high-level sketch"></p><h2 id=hardware-part>Hardware Part<a hidden class=anchor aria-hidden=true href=#hardware-part>#</a></h2><p>To begin start Xilinx Vivado and create a new design.</p><p><img loading=lazy src=/first_post/create_block_design.png#center alt="Create block design"></p><p><img loading=lazy src=/first_post/add_ips_zynq.png#center alt="Add zynq IP"></p><p><img loading=lazy src=/first_post/add_ips_axi_bram.png#center alt="Add BRAM IP"></p><p><img loading=lazy src=/first_post/run_auto_block_and_connection.png#center alt="Run auto block and connection"></p><p><code>Tools --> Create and Package New IP ...</code></p><p><img loading=lazy src=/first_post/create_axi_component.png#center alt="Create and Package New IP&amp;hellip;"></p><p>Then click <code>Next ></code></p><p>On the next screen select <code>Create a new AXI4 peripheral</code> and then click <code>Next ></code></p><p>Name your IP as you want. Me I named it axi_adder. Then click <code>Next ></code></p><p>On the tab with the interface of the AXI leave everything as is and just click <code>Next ></code></p><p>After in the final tab select <code>Edit IP</code> and click <code>Finish</code>.</p><p>This will open your AXI wrapper IP in a new Vivado window.
Inside this AXI wrapper we need to add our own IP.
To add an IP click on the &lsquo;+&rsquo; symbol.</p><p><img loading=lazy src=/first_post/asdf.png#center alt="Add sources"></p><p>Then click <code>Create File</code>. In the window that pops up put us <code>File Type</code> SystemVerilog, <code>File Name</code> adder
and <code>File Location</code> anywhere you want preferably in the same folder as the IP. Click <code>OK</code> and then <code>Finish</code>.</p><p>A new window will popup called <code>Define Module</code> to help you create the header of your IP. You can ignore it since
you will copy paste the code below. Click <code>OK</code> to generate the file.</p><p>In your hierarchy now you should have the adder file.</p><p><img loading=lazy src=/first_post/adder_file_hierarchy.png#center alt="Adder file hierarchy"></p><p>In the adder.sv file copy and paste the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-systemverilog data-lang=systemverilog><span style=display:flex><span><span style=color:#66d9ef>module</span> adder(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] num1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] num2,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>assign</span> sum <span style=color:#f92672>=</span> num1 <span style=color:#f92672>+</span> num2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span></span></span></code></pre></div><p>Now we need to connect the 2 inputs to the 2 out of the 4 registers provided from the AXI slave interface and the output to one of the 2 remaining. To do this open the AXI slave file axi_adder_v1_0_S00_AXI.v and change the following parts:</p><p>Between lines 103 and 110 replace the &lsquo;reg&rsquo; of slv_reg2 with &lsquo;wire&rsquo; as it will be our output register.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-systemverilog data-lang=systemverilog><span style=display:flex><span><span style=color:#75715e>//----------------------------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e>//-- Signals for user logic register space example
</span></span></span><span style=display:flex><span><span style=color:#75715e>//------------------------------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e>//-- Number of Slave Registers 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> [C_S_AXI_DATA_WIDTH<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>]	slv_reg0;
</span></span><span style=display:flex><span><span style=color:#66d9ef>reg</span> [C_S_AXI_DATA_WIDTH<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>]	slv_reg1;
</span></span><span style=display:flex><span><span style=color:#66d9ef>wire</span> [C_S_AXI_DATA_WIDTH<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>]	slv_reg2; <span style=color:#75715e>// Turned to wire for the adder output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> [C_S_AXI_DATA_WIDTH<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>]	slv_reg3;</span></span></code></pre></div><p>From the process that writes to all slv_reg registers (lines 219-269) remove the slv_reg2 as it will be written from our IP.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-systemverilog data-lang=systemverilog><span style=display:flex><span><span style=color:#66d9ef>always</span> @( <span style=color:#66d9ef>posedge</span> S_AXI_ACLK )
</span></span><span style=display:flex><span><span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( S_AXI_ARESETN <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span> )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        slv_reg0 <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        slv_reg1 <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>//	      slv_reg2 &lt;= 0;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        slv_reg3 <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (slv_reg_wren)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> ( axi_awaddr[ADDR_LSB<span style=color:#f92672>+</span>OPT_MEM_ADDR_BITS:ADDR_LSB] )
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>2&#39;h0</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> ( byte_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; byte_index <span style=color:#f92672>&lt;=</span> (C_S_AXI_DATA_WIDTH<span style=color:#f92672>/</span><span style=color:#ae81ff>8</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; byte_index <span style=color:#f92672>=</span> byte_index<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> )
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ( S_AXI_WSTRB[byte_index] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> ) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Respective byte enables are asserted as per write strobes 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Slave register 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            slv_reg0[(byte_index<span style=color:#f92672>*</span><span style=color:#ae81ff>8</span>) <span style=color:#f92672>+:</span> <span style=color:#ae81ff>8</span>] <span style=color:#f92672>&lt;=</span> S_AXI_WDATA[(byte_index<span style=color:#f92672>*</span><span style=color:#ae81ff>8</span>) <span style=color:#f92672>+:</span> <span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>2&#39;h1</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> ( byte_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; byte_index <span style=color:#f92672>&lt;=</span> (C_S_AXI_DATA_WIDTH<span style=color:#f92672>/</span><span style=color:#ae81ff>8</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; byte_index <span style=color:#f92672>=</span> byte_index<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> )
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ( S_AXI_WSTRB[byte_index] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> ) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Respective byte enables are asserted as per write strobes 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Slave register 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            slv_reg1[(byte_index<span style=color:#f92672>*</span><span style=color:#ae81ff>8</span>) <span style=color:#f92672>+:</span> <span style=color:#ae81ff>8</span>] <span style=color:#f92672>&lt;=</span> S_AXI_WDATA[(byte_index<span style=color:#f92672>*</span><span style=color:#ae81ff>8</span>) <span style=color:#f92672>+:</span> <span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>2&#39;h2</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> ( byte_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; byte_index <span style=color:#f92672>&lt;=</span> (C_S_AXI_DATA_WIDTH<span style=color:#f92672>/</span><span style=color:#ae81ff>8</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; byte_index <span style=color:#f92672>=</span> byte_index<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> )
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ( S_AXI_WSTRB[byte_index] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> ) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Respective byte enables are asserted as per write strobes 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Slave register 2
</span></span></span><span style=display:flex><span><span style=color:#75715e>//	                slv_reg2[(byte_index*8) +: 8] &lt;= S_AXI_WDATA[(byte_index*8) +: 8];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>2&#39;h3</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> ( byte_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; byte_index <span style=color:#f92672>&lt;=</span> (C_S_AXI_DATA_WIDTH<span style=color:#f92672>/</span><span style=color:#ae81ff>8</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; byte_index <span style=color:#f92672>=</span> byte_index<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> )
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ( S_AXI_WSTRB[byte_index] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> ) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Respective byte enables are asserted as per write strobes 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Slave register 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            slv_reg3[(byte_index<span style=color:#f92672>*</span><span style=color:#ae81ff>8</span>) <span style=color:#f92672>+:</span> <span style=color:#ae81ff>8</span>] <span style=color:#f92672>&lt;=</span> S_AXI_WDATA[(byte_index<span style=color:#f92672>*</span><span style=color:#ae81ff>8</span>) <span style=color:#f92672>+:</span> <span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>end</span>  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>                    slv_reg0 <span style=color:#f92672>&lt;=</span> slv_reg0;
</span></span><span style=display:flex><span>                    slv_reg1 <span style=color:#f92672>&lt;=</span> slv_reg1;
</span></span><span style=display:flex><span><span style=color:#75715e>//	                      slv_reg2 &lt;= slv_reg2;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    slv_reg3 <span style=color:#f92672>&lt;=</span> slv_reg3;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>endcase</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span></span></span></code></pre></div><p>And just before the <strong>endmodule</strong> keyword there are 2 comments saying &lsquo;Add user logic here&rsquo;. Between those comments add the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-systemverilog data-lang=systemverilog><span style=display:flex><span><span style=color:#75715e>// Add user logic here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>adder adder_i (
</span></span><span style=display:flex><span>    .num1 (slv_reg0),
</span></span><span style=display:flex><span>    .num2 (slv_reg1),
</span></span><span style=display:flex><span>    .sum  (slv_reg2)
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// User logic ends
</span></span></span></code></pre></div><p>This will connect our IP&rsquo;s 2 inputs to 2 of the slv_reg that we can read/write from the CPU and connect the output to slv_reg2 which we will be able to read-only.</p><p><strong>WARNING: It is adviced to try a synthesis run before closing the IP to make sure there was no mistake during the code editing part.</strong></p><p>After that after merging the changes and you are asked if you want to close the project click OK.</p><p>Back on our design now that we created our IP we need to add it on our design. Just open the block design by clicking <code>Open Block Design</code> on the left and
right click in the schematic and click <code>Add IP...</code> and search for <code>axi_adder</code> and add it in the design. Then on top you will again get the do automatic connection suggestion
from Vivado. Click on it and let Vivado create a connection to our axi_adder automatically from the interconnect.</p><p>In the end your schematic diagram should look like the one on the image below:</p><p><img loading=lazy src=/first_post/final_diagram.png#center alt="Final diagram"></p><p>Then you need to create an HDL wrapper and generate the bitstream.</p><p><img loading=lazy src=/first_post/create_hdl_wrapper.png#center alt="Create HDL Wrapper"></p><p>After this is done export the hardware with the bitstream.</p><p><img loading=lazy src=/first_post/export_xsa.png#center alt="Export XSA file"></p><p>On the first window click <code>Next ></code> and then on the next window from the options check the <code>Include bitstream</code> and then click <code>Next ></code>. On the next window make sure you remember the path where you save the .xsa file as we will source it in the Vitis tool to create our software.</p><p>Then open the Vitis toolchain by clicking from the top tabs
<code>Tools --> Launch Vitis IDE</code> and then click Launch on the next popup window to start the software part of the design.</p><h2 id=software-part>Software Part<a hidden class=anchor aria-hidden=true href=#software-part>#</a></h2><p>After Vitis SDK loads we start by creating a new application.</p><p><img loading=lazy src=/first_post/create_new_application.png#center alt="Create new application"></p><p>On the first popup welcome window click <code>Next ></code> and then on the second window
choose to create a new platform with the XSA file created from Vivado.</p><p><img loading=lazy src=/first_post/create_xsa_platform.png#center alt="Create XSA platform"></p><p>Then on the next window called Application Project Details give a name to your project for example axi_adder_test and leave the remaining choices as they are.
Next window called Domain click <code>Next ></code> and on the final window called Templates
choose <code>Hello World</code> and then click <code>Finish</code>.</p><p>We create this application to initiate our CPU cores to a working state and allow us to access the FPGA by lowering the level shifters.</p><p>To test our IP through software I put 2 ways. The first one which I consider the easiest is with XSCT. The second one is writing a C application and watching through a UART terminal the output.</p><h3 id=testing-the-hardware-with-xsct>Testing the hardware with XSCT<a hidden class=anchor aria-hidden=true href=#testing-the-hardware-with-xsct>#</a></h3><p>Now we need to first build the project and then run it.
To build right-click the C application and run <code>Build Project</code> and wait for some
seconds for it to build.</p><p><img loading=lazy src=/first_post/build_project.png#center alt="Build Software Project"></p><p>After the application has been build connect to your FPGA board and power it on.</p><p>Run the application on the FPGA. This will program the FPGA and run the hello world test on it.</p><p><img loading=lazy src=/first_post/run_application.png#center alt="Run application"></p><p>Now we should be able to use the XSCT console to access the FPGA part through the ARM
cores. To do this you can run the commands below on the XSCT console.</p><p><img loading=lazy src=/first_post/testing_the_adder.png#center alt="Testing the adder"></p><p>Here I use the first 2 registers of the design as input numbers and the third one as output of the sum of the addition. The addresses used were given from Vivado. You can find them in the address editor in Vivado tool in your schematic viewer.</p><p><img loading=lazy src=/first_post/address_editor.png#center alt="Address editor"></p><h3 id=testing-the-hardware-with-a-c-application>Testing the hardware with a C application<a hidden class=anchor aria-hidden=true href=#testing-the-hardware-with-a-c-application>#</a></h3><p>We can also do it using a C program and a UART terminal to read the results.
For a UART terminal in this example I used Putty and I opened it using <code>sudo putty</code>.</p><p><img loading=lazy src=/first_post/putty_config.png#center alt="Putty config"></p><p>To find which port to listen to for UART data I did a <code>dmesg</code> on my terminal and when I powered-on my FPGA I saw which ttyUSB port it used.</p><p><img loading=lazy src=/first_post/putty_listen_port.png#center alt="Putty listen port"></p><p>For the UART baud rate (or the field Speed in Putty) you can look inside the comments in the helloworld.c file. It is 115200.</p><p><img loading=lazy src=/first_post/helloworld_cfile.png#center alt="helloworld file"></p><p>Now copy this C code and replace the int main() program inside the helloworld.c file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;platform.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;xil_printf.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>init_platform</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> <span style=color:#f92672>*</span>axi_adder_ptr <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span> <span style=color:#f92672>*</span>) <span style=color:#ae81ff>0x43C00000</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>axi_adder_ptr <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x11223344</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>(axi_adder_ptr <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x11223344</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;Hello World</span><span style=color:#ae81ff>\n\r</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;The axi adder result is 0x%x&#34;</span>, <span style=color:#f92672>*</span>(axi_adder_ptr <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cleanup_platform</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Build the project and run again with your Putty session open and watch the output of the print.</p><p><img loading=lazy src=/first_post/putty_terminal.png#center alt="Putty terminal"></p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>This concludes the tutorial of designing your hardware IP wrapping it with AXI interface in Vivado and testing its functionality through the Vitis SDK and Zynq cores.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.spyroschiotakis.com/tags/axi/>AXI</a></li><li><a href=https://www.spyroschiotakis.com/tags/xilinx/>Xilinx</a></li><li><a href=https://www.spyroschiotakis.com/tags/vivado/>Vivado</a></li><li><a href=https://www.spyroschiotakis.com/tags/vitis/>Vitis</a></li><li><a href=https://www.spyroschiotakis.com/tags/fpga/>FPGA</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.spyroschiotakis.com/>Spyrous Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>